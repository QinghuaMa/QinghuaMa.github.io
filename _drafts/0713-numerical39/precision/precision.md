https://zhidao.baidu.com/question/363432044.html



# 二进制与十进制之间的转换

## 将十进制数转换为二进制数

将一个十进制数字转化为二进制，最简单的方式是将数字的整数部分和小数部分分别对待，比如对于十进制数字 $(53.7)_{10}$ 可以写作 $(53.7)_{10}=(53)_{10}+(0.7)_{10}$，将整数部分和小数部分分别转化为二进制数字，再把结果组合起来，就可以得到 $53.7$ 完整的二进制表示。

**（1）整数部分**

在将十进制转化为二进制时，将整数连续被2除并保留余数，余数只可能是0或者1
$$
\begin{align*}
53\ 除\ 2&=26\ 余\ 1\\
26\ 除\ 2&=13\ 余\ 0\\
13\ 除\ 2&=6\ 余\ 1\\
6\ 除\ 2&=3\ 余\ 0\\
3\ 除\ 2&=1\ 余\ 1\\
1\ 除\ 2&=0\ 余\ 1\\
\end{align*}
$$

最后，将余数从下到上排列，就可以得到 $(53)_{10}=(110101.)_2$

**（2）小数部分**

将上述的计算过程反过来就可以将十进制小数 $(0.7)_{10}$ 转化为二进制。将小数部分不断乘 2 并记录整数部分
$$
\begin{align*}
0.7\times2&=0.4+1\\
0.4\times2&=0.8+0\\
0.8\times2&=0.6+1\\
0.6\times2&=0.2+1\\
0.2\times2&=0.4+0\\
0.4\times2&=0.8+0\\
\cdots
\end{align*}
$$
可以看到，第6步和第2步的表达式是一致的，因此整个过程会呈现出一种循环，因此可以记作 $(0.7)_{10}=(0.1\overline{0110})_2$.

将整数部分和小数部分放到一起，可以得到 
$$
(53.7)_2=(110101.1\overline{0110})_2\notag
$$

## 将二进制数转换为十进制数

将二进制数转换为十进制，还是需要将整数部分和小数部分分别计算。

**（1）整数部分**

二进制数 $(10101)_2$ 可以转换为十进制 $(21)_{10}$
$$
1\times2^0+0\times2^1+1\times2^2+0\times2^3+1\times2^4=21\notag
$$
**（2）小数部分**

二进制小数部分的转换，分为两种情形：有限位小数的转换、无限位小数的转换。

如果小数部分有限，则以类似的方式进行转换，如
$$
(0.1011)_2=1\times\dfrac12+0\times\dfrac14+1\times\dfrac18+1\times\dfrac{1}{16}=(\dfrac{11}{16})_{10}\notag
$$
如果小数部分有无限位时，转化会变得复杂一点，一种简单的方法是利用2乘的平移性质。

以将 $x=(0.\overline{1011})_2$ 转化为十进制为例。把 $x$ 和 $2^4$ 相乘，意味着在二进制中向左平移4位，则有：
$$
\begin{align*}
x&=0000.\overline{1011}\\
2^4x&=1011.\overline{1011}
\end{align*}
$$
相减得到
$$
(2^4-1)x=(1011)_2=(11)_2\notag
$$
于是可以解出
$$
x=\dfrac{11}{15}\notag
$$
如果分数部分没有立即循环，例如对于 $x=0.10\overline{101}$，则有
$$
\begin{align*}
x&=0.10\overline{101}\\
y=2^2x&=10.\overline{101}\\

\end{align*}
$$
令 $z=0.\overline{101}$，则有
$$
\begin{align*}
2^3z&=101.\overline{101}\\
z&=000.\overline{101}
\end{align*}
$$
则可以解出
$$
\begin{align*}
&(2^3-1)z=(101)_2=5\\
\Rightarrow&z=\dfrac57
\end{align*}
$$
即
$$
\begin{align*}
&2^2x=(10.\overline{101})_2=2+\dfrac57\\
\Rightarrow&x=\dfrac{19}{28}
\end{align*}
$$

# IEEE 754 标准定义的浮点数

## 标准化

IEEE浮点标准所定义的浮点数字主要包含三个部分，分别是：符号（$+$ 或者 $-$）、尾数和指数。浮点数有三种常用的精度级别：单精度、双精度和扩展精度（也称为长双精度）。这三种精度都可以用**标准化**的IEEE浮点数表示为：

<img src="https://blogimages-1309804558.cos.ap-nanjing.myqcloud.com/imgpersonal/image-20220721235015059.png" alt="image-20220721235015059" style="zoom:50%;" />

其中，**标准化**意味着，主导数位（最左边的一位）必须是1。

> 注意：数字 $0$ 就明显不能被标准化，它也被称为异常浮点数字，后面会深入讲解这一点。

三种浮点数精度的数位(bit，即 $s+b+p$ 的位数加和)分别是32、64、80，这些数位的分配方式如下表所示：

| 精度                 | 符号(s) | 指数(p) | 尾数(b) | $s+b+p$ |
| -------------------- | ------- | ------- | ------- |------- |
| 单精度               | 1       | 8       | 23      |32|
| 双精度               | 1       | 11      | 52      |64|
| 长双精度（扩展精度） | 1       | 15      | 64      |80|



## 机器精度

根据 IEEE 754 所定义的标准化浮点格式，数字 $1$ 的双精度浮点格式可以表示为
$$
+1.0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\times2^0\notag
$$

> 最左边的1不算入52位尾数当中

下一个比数字1大的浮点数为：
$$
+1.0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\times2^0\notag
$$
由此，我们就可以得到机器精度的定义。

机器精度（machine epsilon），记作 $\varepsilon_{mach}$，**定义为 1 和比 1 大的最小的浮点数之间的距离**。对于上述IEEE双精度浮点数，有 $\varepsilon_{mach}=2^{-52}\approx2.2^{-16}$ 。但是，由上述定义可以看出，并不是任意两个相邻浮点数之间的距离都是 $\varepsilon_{mach}$ 。任意两个相邻浮点数之间的距离受它们整数部分的影响，因为整数部分和小数部分一起来分担尾数的52位二进制数；更准确地讲，**任意两个相邻浮点数之间的距离受后面指数部分的影响，其值是 $2^{-52}\times2^{p}$**。我们很容易验证这一点。在MATLAB中，得到 $2^{52}$（它的双精度浮点数表示的指数部分为$(52)_{10}$） 的具体值以及它的浮点数表示：

```matlab
>> format long
>> 2^52
ans =
     4.503599627370496e+15
>> num2hex(ans)
ans =
    '4330000000000000'
```

之后，计算比它大的下一个浮点数所表示的数字：

```matlab
hex2num('4330000000000001')
ans =
     4.503599627370497e+15
```

可以看到，它们之间的间隔为 $2^{-52}\times2^{52}=1$。

也就是说，双精度计算机并不能**精确**表示 $4503599627370496$ 和 $4503599627370497$ 之间的任意一个小数，哪怕是 $4503599627370496.1$ 也不可以！

我们可以看看 $4503599627370496.1$ 在计算机中是如何表示的：

```matlab
>> num2hex(4503599627370496.1)
ans =
    '4330000000000000'
```

可以看出，$4503599627370496.1$ 的机器表示和 $4503599627370496$ 的机器表示是完全一致的。那么，为什么是一致的？这就需要后面要提到的“拟合”的概念。

==机器精度的意义==



## 拟合

==……==

## 机器表示

根据上述的分析，符合IEEE 754标准的**标准化浮点数**都可以写成如下形式：
$$
\pm1.bbb\cdots b\times 2^p\notag
$$
在机器实现时，以符号s、指数p、尾数b的顺序保存在计算机的字中，以双精度格式为例：

$$
s\vert p_1p_2\cdots p_{11}\vert b_1b_2\cdots b_{52}\notag
$$

其中

1. $s$ 保存了符号位，0表示正数，1表示负数，即$\mathrm{sign}=(-1)^s$；

2. $p_1p_2\cdots p_{11}$ 用于保存指数。11位数位一共可以表示 $0$ 到 $2^{11}-1$ 之间，即 $0$ 到 $2047$ 之间的所有整数。但是计算机在保存指数时，并没有采用第1位为符号位，其余位为数字的形式，而是使用了**指数偏差(Exponent bias)**的概念。

   11位二进制数表示的指数不是真正的指数，而是保存在计算机中的一个值，真正的指数需要通过以下关系式计算获得：真正的指数 = 保存在计算机中的指数（由11位二进制数表示）- 指数偏差。对于双精度而言，它的指数偏差是 $2^{10}-1=1023$。也就是说，11位数位所对应的 $0\sim 2047$ 实际代表着 $-1023\sim 1024$。但是由于一些特殊的需要（后面将要提到），实际上11位所表示的0和2047被保留下来，因此指数的范围实际上只有 $-1022\sim1023$；

3. $b_1b_2\cdots b_{52}$ 用于保存尾数；

4. 被保留下来的指数 $0$ 和 $2047$

   - 被保留下来的指数 $2047$ ，它的二进制表示为 $(111\ 1111\ 1111)_2$，它用于表示 $\infty$ 和 $\mathrm{NaN}$ 的情况，比如 $\mathrm{Inf}$ 的双精度表示为——前12位分别为 $(1111\ 1111\ 1111)_2$，尾数均为0；$\mathrm{-Inf}$ 的前12位分别为 $(0\vert111\ 1111\ 1111)_2$，尾数均为0；而 $\mathrm{NaN}$ 的前12位分别为 $(1\vert111\ 1111\ 1111)$ ，尾数不全为0。

   | 机器数          | 例子 | 十六进制数                         |
   | --------------- | ---- | ---------------------------------- |
   | $\mathrm{+Inf}$ | 1/0  | 7FF0000000000000                   |
   | $\mathrm{-Inf}$ | -1/0 | FFF0000000000000                   |
   | $\mathrm{NAN}$  | 0/0  | FFFXXXXXXXXXXXXX(X表示不全为0的位) |

   我们可以在 MATLAB 中验证一下

   ```matlab
   % +Inf----------------------------
   >> num2hex(1/0)
   ans =
       '7ff0000000000000'
   >> num2hex(2/0)
   ans =
       '7ff0000000000000'
       
   % -Inf----------------------------
   >> num2hex(-1/0)
   ans =
       'fff0000000000000'
   >> num2hex(-2/0)
   ans =
       'fff0000000000000'
       
   % NaN----------------------------
   >> num2hex(0/0)
   ans =
       'fff8000000000000'
   
   ```

   - 被保留下来的指数 $0$，它的二进制表示为 $(000\ 0000\ 0000)$，它是**异常(subnormal)浮点数字（即非标准浮点数字）**的标志。上面提到，符合IEEE 754 标准化的浮点数都是“左对齐”的，这意味着最左边的数位假设为1，如果不是1，则通过2乘移位。但是在这种标准化格式的定义下，有一些数字是没有办法表示的，最典型的就是数字 0 无法写成这种标准化的形式。因此，为了拓宽数字的表示范围，IEEE 754标准定义了依靠指数 $0$ 定义了一类非标准的浮点数字。非标准的浮点数字的格式为：
     $$
     \pm 0.b_1b_2\cdots b_{52}\times 2^{-1022}\notag
     $$
     
     > ⚠️ 注意：在非标准浮点数格式中，虽然指数为 $-1022$，但实际上指数的机器表示均为0。在这种定义格式下，那些（试图）标准化后指数满足 $-1022-52\le p\le-1022-1$ 的数字被定义为**异常浮点数字**。
     
     异常浮点数字的存在，使得数字的表示范围得到了扩展，使**最小可表达数字**为 $2^{-52}\times 2^{-1022}=2^{-1074}$ ，它所对应的机器字为
     $$
     0\vert000\ 0000\ 0000\vert0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\notag
     $$
     我们必须理解最小可表达数字 $2^{-1074}$ 和机器精度 $\varepsilon_{mach}=2^{-52}$ 之间的差异。在计算机中，许多在机器精度 $\varepsilon_{mach}=2^{-52}$ 以下的数字其实是**机器可表达的**，但是在 $2^{-1074}$ 以下的双精度数字**完全不能被表示**（它们的数位均为0，即为数字 0）。
     
     异常数字中最重要的是数字 $0$ ，实际上包含 $+0$ 和 $-0$ ，在实际计算中它们被看作两个相同的实数，它们的机器表达分别为：
     $$
     0\vert000\ 0000\ 0000\vert0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\\
     1\vert000\ 0000\ 0000\vert0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\notag
     $$
     同样，我们在 MATLAB 中进行验证：
     
     ```matlab
     >> num2hex(2^(-1074))
     ans =
         '0000000000000001'
         
     >> num2hex(2^(-1077))
     ans =
         '0000000000000000'
         
     >> num2hex(2^(-1031))
     ans =
         '0000080000000000'
     
     >> num2hex(5*2^(-1031))
     ans =
         '0000280000000000'
     
     >> num2hex(+0)
     ans =
         '0000000000000000'
         
     >> num2hex(-0)
     ans =
         '8000000000000000'
     ```
     
     









根据二进制的转换方式，并考虑到IEEE 754浮点数标准所要求的（1）标准化（2）拟合，我们就可以写出所有数字的符合IEEE 754标准的机器表示。为了充分体现出上述过程，分别举出三个将十进制数转换为**机器表示**的例子，并且在MATLAB中进行验证。

（1）将 $(0.1)_{10}$ 转换为机器表示

根据上述十进制向二进制的转换规则，可以得到 
$$
(0.1)_{10}=(0.0\overline{0011})_2\notag
$$
将 $(0.0\overline{0011})_2$  左对齐（即标准化）可以得到
$$
\textcolor{red}{+}1.\textcolor{blue}{1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001}\  1001\cdots\times 2^{\textcolor{green}{-4}}\notag
$$
根据IEEE 754标准所采用的默认的舍入规则
$$
\textcolor{red}{+}1.\textcolor{blue}{1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1010}\  \times 2^{\textcolor{green}{-4}}\notag
$$
将指数加上双精度的指数偏差 $2^{10}-1=1023$
$$
\textcolor{red}{+}1.\textcolor{blue}{1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1010}\  \times 2^{\textcolor{green}{1019}}\notag
$$
按照机器表示方法，可以写成
$$
\textcolor{red}{0}\textcolor{green}{011\ 1111\ 1011}\ \textcolor{blue}{1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1001\ 1010}\notag
$$
将其转换为十六进制
$$
\mathrm{3fb999999999999a}\notag
$$
在 MATLAB 中进行验证：

```matlab
>> num2hex(0.1)
ans =
    '3fb999999999999a'
```



（2）将 





（3）将 $5\times2^{-1037}$ 转换为机器表示

由于指数部分 $-1037$ 超过了 $-1022\sim 1023$ 的表示范围，因此该数字的浮点数一定是异常浮点数（指数位串均为0）。将数字 $5\times2^{-1037}$ 写作非标准浮点数格式：
$$
\begin{align*}
5\times2^{-1037}&=(5)_{10}\times2^{-15}\times 2^{-1022}\\
&=(101)_2\times2^{-15}\times 2^{-1022}\\
&=(0.101)_2\times2^{-12}\times 2^{-1022}
\end{align*}
$$
因此，它的机器表示为： 
$$
\textcolor{red}{0}\textcolor{green}{000\ 0000\ 0000}\ \textcolor{blue}{0000\ 0000\ 0000\ 1010\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000}\notag
$$
将其转换为二进制数
$$
\mathrm{000000a000000000}\notag
$$
在 MATLAB 中进行验证

```matlab
>> num2hex(5*2^(-1037))
ans =
    '000000a000000000'
```





---

在 $1^{-1022}$ 以下的数字无法用标准化的方式表示。

